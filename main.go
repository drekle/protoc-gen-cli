package main

import (
	"bytes"
	"encoding/json"
	"flag"
	"fmt"
	"io"
	"io/ioutil"
	"log"
	"os"
	"strings"
	"text/tabwriter"

	plugin "github.com/golang/protobuf/protoc-gen-go/plugin"
	"google.golang.org/protobuf/proto"

	protochelpers "github.com/drekle/protoc-gen-client/pkg/protoc"
	"github.com/drekle/protoc-gen-client/pkg/template"
)

const (
	Version = "0.1.0"
)

type Config struct {
	Version   string   `json:"version"`
	GitRepo   string   `json:"gitRepository"`
	SkipFiles []string `json:"skipFiles"`
}

func GenConfig() ([]byte, error) {
	return json.MarshalIndent(&Config{
		Version: Version,
	}, " ", "\t")
}

type clientGen struct {
	Request    *plugin.CodeGeneratorRequest
	Response   *plugin.CodeGeneratorResponse
	Parameters map[string]string
	Config     Config
}

func (runner *clientGen) PrintParameters(w io.Writer) {
	const padding = 3
	tw := tabwriter.NewWriter(w, 0, 0, padding, ' ', tabwriter.TabIndent)
	fmt.Fprintf(tw, "Parameters:\n")
	for k, v := range runner.Parameters {
		fmt.Fprintf(tw, "%s:\t%s\n", k, v)
	}
	fmt.Fprintln(tw, "")
	tw.Flush()
}

func (runner *clientGen) GenerateCobra() error {
	// Create a file and append it to the output files
	for _, svc := range protochelpers.GetServices(runner.Request.ProtoFile) {
		for _, procedure := range svc.Procedures {
			goPackage := strings.ReplaceAll(svc.Proto.GetPackage(), ".", "/")
			outfileName := fmt.Sprintf("cmd/%s/%s/%s.go", goPackage, *svc.Name, strings.ToLower(*procedure.Name))
			var buf bytes.Buffer
			t := template.NewTemplate()
			ex, err := t.Parse(template.CobraCommandTemplate)
			if err != nil {
				return err
			}
			err = ex.Execute(&buf, &template.CobraCommandInput{
				Service:   svc,
				GoPBPath:  fmt.Sprintf("gen/%s", goPackage),
				RepoURL:   "github.com/drekle/demo",
				Procedure: procedure,
			})
			if err != nil {
				return err
			}
			var outFile plugin.CodeGeneratorResponse_File
			outFile.Name = &outfileName
			content := buf.String()
			outFile.Content = &content
			runner.Response.File = append(runner.Response.File, &outFile)

		}
	}
	return nil
}

func (runner *clientGen) generateCode() error {
	// Initialize the output file slice
	files := make([]*plugin.CodeGeneratorResponse_File, 0)
	runner.Response.File = files
	{
		err := runner.GenerateCobra()
		if err != nil {
			return err
		}
	}
	return nil
}

func main() {

	stdInFile := flag.String("stdinFile", "", "A file to use for stdin")
	genConfig := flag.Bool("genConfig", false, "Outputs a sample config file and then exits")
	flag.Parse()

	if *genConfig {
		data, err := json.MarshalIndent(&Config{
			Version:   Version,
			GitRepo:   "github.com/organization/protoc-gen-plugin",
			SkipFiles: []string{"dontRegenerate.txt", "dontRegenerateEither.txt"},
		}, " ", "\t")
		if err != nil {
			panic(err)
		}
		println(string(data))
		os.Exit(0)
	}

	// os.Stdin will contain data which will unmarshal into the following object:
	// https://godoc.org/github.com/golang/protobuf/protoc-gen-go/plugin#CodeGeneratorRequest
	req := &plugin.CodeGeneratorRequest{}
	resp := &plugin.CodeGeneratorResponse{}

	// Debugging Support
	data, err := ioutil.ReadAll(os.Stdin)
	if err != nil {
		panic(err)
	}
	if *stdInFile != "" {
		data, err = ioutil.ReadFile(*stdInFile)
		if err != nil {
			panic(err)
		}
	}

	if err := proto.Unmarshal(data, req); err != nil {
		panic(err)
	}

	// You may require more data than what is in the proto files alone.  There are a couple ways in which to do this.
	// The first is by parameters.  Another may be using leading comments in the proto files which I will cover in generateCode.
	parameters := req.GetParameter()
	// =grpc,import_path=mypackage:.
	clientRunner := &clientGen{
		Request:    req,
		Response:   resp,
		Parameters: make(map[string]string),
	}
	groupkv := strings.Split(parameters, ",")
	for _, element := range groupkv {
		kv := strings.Split(element, "=")
		if len(kv) > 1 {
			clientRunner.Parameters[kv[0]] = kv[1]
		}
	}

	// Require a config file as there are likely going to be a growing number of options
	if _, ok := clientRunner.Parameters["config"]; !ok {
		log.Fatalf("A config file must be specified for protoc-gen-client.  One can be generated by `protoc-gen-client --genConfig and can be passed in via --client_opt=config=config.json")
	}
	cfgdata, err := ioutil.ReadFile(clientRunner.Parameters["config"])
	if err != nil {
		log.Fatalf("Failed to read config file: %v", err)
	}
	if err := json.Unmarshal(cfgdata, &clientRunner.Config); err != nil {
		log.Fatalf("Failed to read config file: %v", err)
	}

	err = clientRunner.generateCode()
	if err != nil {
		panic(err)
	}

	marshalled, err := proto.Marshal(resp)
	if err != nil {
		panic(err)
	}
	os.Stdout.Write(marshalled)
}
